
## Authors

**[@pinkeshroy](https://www.github.com/pinkeshroy)**


# react-pwa

**React project into a Progressive Web Application (PWA)**

# Folder Structure
``` 

react-app-name
│
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
│
└── src
    ├── components
    ├── hooks
    ├── icons
    ├── images
    ├── locales
    ├── pages
    ├── redux
    │   └── store.ts
    ├── theme
    ├── App.css
    ├── App.test.tsx
    ├── App.tsx
    ├── index.css
    ├── index.scss
    ├── index.tsx
    ├── react-app-env.d.ts
    ├── reportWebVitals.ts
    ├── service-worker.ts
    ├── serviceWorkerRegistration.ts
    ├── setupTests.ts
    ├── types.d.ts
    ├── .gitignore
    ├── package-lock.json
    ├── package.json
    ├── README.md
    └── tsconfig.json
``` 

# 1. Configure the Manifest:
- Update the `public/manifest.json` with the details specific to your app. This includes icons, the app name, start URL, display type, and theme colors.
``` 
{
  "short_name": "react-app",
  "name": "react-app",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

``` 

# 2. Implementing the Service Worker:
   
- Service Worker Setup: Use the `src/service-worker.ts` for setting up the caching strategies for your app. This includes precaching assets and handling runtime caching.
    
``` /// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic
``` 

 -  Registration: Use the `src/serviceWorkerRegistration.ts` to handle the registration and updates of the service worker. This is configured to work differently based on whether the app is hosted on localhost or a production server.
   ``` 
    // This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
    window.location.hostname === 'localhost' ||
      // [::1] is the IPv6 localhost address.
      window.location.hostname === '[::1]' ||
      // 127.0.0.0/8 are considered localhost for IPv4.
      window.location.hostname.match(
        /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/
      )
  );
  
  type Config = {
    onSuccess?: (registration: ServiceWorkerRegistration) => void;
    onUpdate?: (registration: ServiceWorkerRegistration) => void;
  };
  
  export function register(config?: Config) {
    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
      // The URL constructor is available in all browsers that support SW.
      const publicUrl = new URL(
        process.env.PUBLIC_URL??"",
        window.location.href
      );
      if (publicUrl.origin !== window.location.origin) {
        // Our service worker won't work if PUBLIC_URL is on a different origin
        // from what our page is served on. This might happen if a CDN is used to
        // serve assets; see https://github.com/facebook/create-react-app/issues/2374
        return;
      }
  
      window.addEventListener('load', () => {
        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;
  
        if (isLocalhost) {
          // This is running on localhost. Let's check if a service worker still exists or not.
          checkValidServiceWorker(swUrl, config);
  
          // Add some additional logging to localhost, pointing developers to the
          // service worker/PWA documentation.
          navigator.serviceWorker.ready.then(() => {
            console.log(
              'This web app is being served cache-first by a service ' +
                'worker. To learn more, visit https://cra.link/PWA'
            );
          });
        } else {
          // Is not localhost. Just register service worker
          registerValidSW(swUrl, config);
        }
      });
    }
  }
  
  function registerValidSW(swUrl: string, config?: Config) {
    navigator.serviceWorker
      .register(swUrl)
      .then((registration) => {
        registration.onupdatefound = () => {
          const installingWorker = registration.installing;
          if (installingWorker == null) {
            return;
          }
          installingWorker.onstatechange = () => {
            if (installingWorker.state === 'installed') {
              if (navigator.serviceWorker.controller) {
                // At this point, the updated precached content has been fetched,
                // but the previous service worker will still serve the older
                // content until all client tabs are closed.
                console.log(
                  'New content is available and will be used when all ' +
                    'tabs for this page are closed. See https://cra.link/PWA.'
                );
  
                // Execute callback
                if (config && config.onUpdate) {
                  config.onUpdate(registration);
                }
              } else {
                // At this point, everything has been precached.
                // It's the perfect time to display a
                // "Content is cached for offline use." message.
                console.log('Content is cached for offline use.');
  
                // Execute callback
                if (config && config.onSuccess) {
                  config.onSuccess(registration);
                }
              }
            }
          };
        };
      })
      .catch((error) => {
        console.error('Error during service worker registration:', error);
      });
  }
  
  function checkValidServiceWorker(swUrl: string, config?: Config) {
    // Check if the service worker can be found. If it can't reload the page.
    fetch(swUrl, {
      headers: { 'Service-Worker': 'script' },
    })
      .then((response) => {
        // Ensure service worker exists, and that we really are getting a JS file.
        const contentType = response.headers.get('content-type');
        if (
          response.status === 404 ||
          (contentType != null && contentType.indexOf('javascript') === -1)
        ) {
          // No service worker found. Probably a different app. Reload the page.
          navigator.serviceWorker.ready.then((registration) => {
            registration.unregister().then(() => {
              window.location.reload();
            });
          });
        } else {
          // Service worker found. Proceed as normal.
          registerValidSW(swUrl, config);
        }
      })
      .catch(() => {
        console.log(
          'No internet connection found. App is running in offline mode.'
        );
      });
  }
  
  export function unregister() {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.ready
        .then((registration) => {
          registration.unregister();
        })
        .catch((error) => {
          console.error(error.message);
        });
    }
  }
``` 

# 3. Modify _index.tsx_ for PWA: 
- Ensure `serviceWorker.register()` is called in your index.tsx to activate the service worker when the app is loaded.
```   {
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import reportWebVitals from "./reportWebVitals";
import { Provider } from "react-redux";
import store from "./redux/store";
import "./locales/locale.ts";
import * as serviceWorker from "./serviceWorkerRegistration";

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(
  <Provider store={store}>
    <React.StrictMode>
      <App />
    </React.StrictMode>
  </Provider>
);
serviceWorker.register();
// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();}

``` 

# 4. Dependencies: 
- Install the necessary Workbox libraries that facilitate the service worker functionality by running this command in your project directory:
``` npm install workbox-core workbox-expiration workbox-precaching workbox-routing workbox-strategies``` 

# 5. Testing: 
- After implementing the above changes, test the app in both development and production modes to ensure that the service worker is functioning as expected. Make sure to test offline capabilities and update handling.

# 6. Optimization and Best Practices: 
- Review the PWA criteria using Lighthouse in Chrome DevTools to ensure your app meets all the recommended guidelines for a Progressive Web Application.


# **Progressive Web Application (PWA) into a Trusted Web Activity (TWA) using Bubblewrap**

Prerequisites
- Before starting, ensure you have Node.js installed. 
- You will also need the Java Development Kit (JDK) [Link](https://adoptium.net/en-GB/temurin/releases/?version=17&package=jdk) 
- The Android SDK command-line tools to proceed[Link](https://developer.android.com/studio#command-line-tools-only).
- Also deploy your app on `netlify.com`  or somewhere as your choice

``` 
1. Install Bubblewrap CLI
Install the Bubblewrap Command Line Interface globally using npm. This tool helps package your PWA into an Android application.
``` npm install -g @bubblewrap/cli ``` 
2. Prepare the Environment
Set up directories and download the necessary SDKs and JDK:
`
# Create a directory for the project
mkdir MBookingPwa
cd MBookingPwa

# Download and unzip Android SDK command line tools
unzip -d android-sdk ~/Downloads/commandlinetools-linux-10406996_latest.zip

# Download and extract Open JDK
tar -xvzf ~/Downloads/OpenJDK17U-jdk_aarch64_linux_hotspot_17.0.12_7.tar.gz

# Move the JDK folder for easier access
mv jdk-17.0.12+7/ jdk

# Create a directory for the TWA project
mkdir mbooking-app
cd mbooking-app
`

3. Initialize the TWA Project
Use Bubblewrap to initialize your TWA project by pointing it to the web manifest of your existing PWA.

`bubblewrap init --manifest=https://delivergrocery.netlify.app/manifest.json
`
_This command will generate a configuration file and ask for key details about your application, such as the application name, launcher name, theme color, etc. It will also generate an Android project based on these settings._

4. Build the TWA
After setting up your configuration and modifying any necessary details in the generated files, you can build the TWA package.
`bubblewrap build
`
This command compiles your project into an APK file that can be distributed through the Google Play Store or other Android markets.
``` 

*_Tips for TWA_*

- Ensure your PWA is served over HTTPS, as this is a requirement for TWA.
- Verify your PWA with Digital Asset Links to ensure the Android app can prove ownership of the PWA.
- Test the TWA on multiple Android devices to ensure compatibility and performance.

Post-Build Steps

- Test your APK on different devices to ensure it works correctly.
- Publish your APK to the Google Play Store following their publishing guidelines.
- Monitor the performance of your app in the Play Console and make necessary updates or optimizations.
- This documentation provides a step-by-step approach to converting your PWA to a TWA using Bubblewrap, ensuring a smooth transition and successful deployment on the Android platform.


# **_Additional Resources_**

Converting Logos for App Manifest

- When preparing your Progressive Web Application (PWA) or Trusted Web Activity (TWA), it's essential to have appropriately sized icons that comply with the specifications of manifest.json. These icons are used across various platforms where your app is installed or featured. To ensure your logos meet these requirements, you can use online tools to convert and optimize them.

Recommended Tool:

- Favicon Converter: This online tool allows you to convert standard image files into icons suitable for use in your app's manifest.json. You can access the tool at Favicon.io Favicon Converter.

_Steps to Convert Your Logo:_

1. Visit the Website: Go to [Documentation](https://favicon.io/favicon-converter/) .
2. Upload Your Logo: Select and upload your original high-resolution logo file.
3. Specify Icon Requirements: Choose the sizes and formats that you need for your app's manifest. Typical sizes include 192x192 for Android devices and 512x512 for splash screens and app launch icons.
4. Download the Converted Files: Once the conversion is complete, download the generated favicon files.
5. Integrate into Your Project: Place the downloaded icons in the appropriate directory (usually within the public/ folder for most web projects) and reference them in your _manifest.json_.

